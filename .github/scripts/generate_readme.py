#!/usr/bin/env python3
import os
import json

# If you keep projects in a "projects" folder change this variable to 'projects'
PROJECTS_ROOT = "projects" if os.path.isdir("projects") else "."

EXCLUDE_FOLDERS = {".github", ".git", ".vscode", "node_modules"}

README_TEMPLATE = """# {title}

## üìå Project Overview
{description}

## üõ†Ô∏è Potential Technologies / Tools
{tools_list}

## üöÄ How to Run
1. Clone this repository
2. Navigate to this project folder
3. Install dependencies (e.g. `pip install -r requirements.txt`)
4. Run the code (follow project-specific instructions)

---
‚úÖ Auto-generated by ML Projects Bot ü§ñ
"""

DEFAULT_DESCRIPTION = "This project is part of the Machine-learning-projects-collection-100-plus-projects-with-source-code repository."
DEFAULT_TOOLS = "Python, Pandas, Scikit-learn (customize for your project)"

KEYWORD_STACKS = {
    "spam": "Python, Scikit-learn, NLTK, Naive Bayes",
    "sentiment": "Python, NLTK, Scikit-learn, TextBlob",
    "stock": "Pandas, yfinance, LSTM, TensorFlow/Keras",
    "price": "Pandas, Scikit-learn, Regression / Time-series",
    "image": "TensorFlow/Keras, OpenCV, CNN",
    "ocr": "Tesseract, OpenCV, EasyOCR",
    "fraud": "Scikit-learn, IsolationForest, XGBoost",
    "classification": "Scikit-learn, RandomForest, LogisticRegression",
    "regression": "Scikit-learn, LinearRegression, XGBoost",
    "segmentation": "U-Net, TensorFlow/PyTorch",
}

def format_title(name):
    return name.replace("-", " ").replace("_", " ").title()

def guess_tools(name):
    lower = name.lower()
    for k,v in KEYWORD_STACKS.items():
        if k in lower:
            return v
    return DEFAULT_TOOLS

def load_metadata(folder):
    # Supports optional project.json containing {"name": "...", "description": "...", "tools": ["t1","t2"]}
    meta_path = os.path.join(folder, "project.json")
    if os.path.exists(meta_path):
        try:
            with open(meta_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            print(f"Could not parse {meta_path}: {e}")
    return None

def write_readme(folder, title, description, tools):
    readme_path = os.path.join(folder, "README.md")
    if os.path.exists(readme_path):
        print(f"README exists for {folder}, skipping.")
        return False
    tools_list = "\n".join(f"- {t}" for t in (tools.split(",") if isinstance(tools, str) else tools))
    content = README_TEMPLATE.format(title=title, description=description, tools_list=tools_list)
    with open(readme_path, "w", encoding="utf-8") as f:
        f.write(content)
    print(f"Generated README.md for {folder}")
    return True

def main():
    base = os.getcwd()
    candidates = []
    if PROJECTS_ROOT == ".":
        # all top-level directories except excluded ones
        for name in os.listdir("."):
            if os.path.isdir(name) and name not in EXCLUDE_FOLDERS:
                candidates.append(name)
    else:
        root_path = os.path.join(base, PROJECTS_ROOT)
        for name in os.listdir(root_path):
            full = os.path.join(root_path, name)
            if os.path.isdir(full) and name not in EXCLUDE_FOLDERS:
                candidates.append(full)

    any_written = False
    for folder in sorted(candidates):
        full_path = folder if PROJECTS_ROOT == "." else os.path.join(PROJECTS_ROOT, os.path.basename(folder))
        meta = load_metadata(full_path)
        if meta:
            title = meta.get("name", format_title(os.path.basename(full_path)))
            description = meta.get("description", DEFAULT_DESCRIPTION)
            tools = meta.get("tools", guess_tools(os.path.basename(full_path)))
            tools_str = ", ".join(tools) if isinstance(tools, list) else tools
        else:
            title = format_title(os.path.basename(full_path))
            description = DEFAULT_DESCRIPTION
            tools_str = guess_tools(os.path.basename(full_path))

        created = write_readme(full_path, title, description, tools_str)
        any_written = any_written or created

    if not any_written:
        print("No new README files generated.")

if __name__ == "__main__":
    main()
